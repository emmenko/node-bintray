#!/usr/bin/env node
var fs = require('fs');
var path = require('path');
var _ = require('lodash');
var program = require('commander');
var Bintray = require('../lib/bintray');
var pkg = require('../package.json');
require('colors');

var authStoreFile = __dirname + '/../data/authfile.json';
var exit = 0;

function log() {
  console.log.apply(null, Array.prototype.slice.call(arguments));
}

program
  .version(pkg.version)

program.on('--help', function(){
  log('  Examples:');
  log('');
  log('    $ bintray auth set -u username -p apikey -s myOrganization');
  log('    $ bintray package search -r myrepository nodejs');
  log('');
});

program
  .command('auth')
  .description('Defines the Bintray authentication credentials')
  .usage('[options]')
  .option('-c, --clean', 'Clean the stored authentication credentials')
  .option('-u, --username <username>', 'Bintray username')
  .option('-k, --apikey <apikey>', 'User API key')
  .on('--help', function () {
    log('  Auth usage examples:');
    log('');
    log('    $ bintray auth -u myuser -k myapikey');
    log('    $ bintray auth --show');
    log();
  })
  .action(function (options) {
    var authData,
        storeExists = fs.existsSync(authStoreFile);

    if (options.clean) {
      if (storeExists) {
        fs.unlinkSync(authStoreFile);
        log('Authentication data cleaned'.green);
      } else {
        log('No authentication credentials defined, nothing to clean'.green);
      }
    } else if (!options.username && !options.apikey) {
      if (fs.existsSync(authStoreFile)) {
        authData = require(authStoreFile);
        log('Username:', authData.username);
        log('API key: ', authData.apikey);
        log('\nType --help to see the available options');
      } else {
        log('No authentication data defined. Use:');
        log('$ bintray auth -u myuser -k myapikey'.grey);
      }
    } else {
      if (!options.username || !options.apikey) {
        log('Both username and apikey params are required'.red);
        exit = 1;
      } else {
        authData = { username: options.username, apikey: options.apikey };
        fs.writeFileSync(authStoreFile, JSON.stringify(authData, null, 2));
        log('Authentication data saved'.green);
      }
    }
  });

program
  .command('package <subject> <repository> <action> [pkgname] [pkgfile]')
  .description('Get, update, delete or create Bintray packages')
  .usage('<subject> <repository> <list|info|create|delete|update> [pkgname] [pkgfile]?')
  //.option('-s, --subject <subject>', 'Bintray subject/organization name (required)')
  .option('-o, --output [json]', 'Output JSON response')
  .option('-f, --file [path]', '[create|update] Path to JSON manifest file')
  .option('-s, --start-pos [number]', '[list] Packages list start position')
  .option('-n, --start-name [prefix]', '[list] Packages start name prefix filter')
  .on('--help', function () {
    log('  Usage examples:');
    log('');
    log('    $ bintray package mycompany myrepository list');
    log('    $ bintray package mycompany myrepository info mypackage');
    log();
  })
  .action(function (subject, repository, action, pkgname, pkgfile, options) {
    var actions = [ 'list', 'info', 'create', 'delete', 'update' ];
    action = action.toLowerCase();

    if (!subject || !repository) {
      log('Subject and repository command required. Type --help'.red);
      exit = 1;
      return;
    }

    if (actions.indexOf(action) === -1) {
      log('Invalid action. Type --help'.red);
      exit = 1;
      return;
    }

    function requireAuth() {
      if (!fs.existsSync(authStoreFile)) {
        return false;
      } else {
        return require(authStoreFile);
      }
    }

    var authStore = requireAuth();
    var client = new Bintray(authStore.username, authStore.apikey, subject, repository);
    
    switch (action) {
      case 'list':
        // no auth
        options.startPos = parseInt(options.startPos, 10) || 0;

        client.getPackages(options.startPos, options.startName)
          .then(function (response) {
            response = response.data;
            if (response.length) {
              if (options.output === 'json') {
                log(response);
              } else {
                log('Available packages at "', repository, '" repository');
                response.forEach(function (pkg) {
                  log(pkg.name);
                });
              }
            } else {
              log('No packages found'.red);
            }
          }, function (error) {
            if (error.code === 404) {
              log('Repository not found'.red);
            } else {
              log('Error while trying to get the resource, server code:'.red, error.code || error);
            }
            exit = 1;
          });

        break;

      case 'info':

        if (!pkgname) {
          log('Package name option required. Type --help'.red);
          exit = 1;
          return;
        }

        client.getPackage(pkgname)
          .then(function (response) {
            var pkg = response.data;
            if (pkg && pkg.name) {
              if (options.output === 'json') {
                log(pkg);
              } else {
                log('%s %s [%s/%s] %s', pkg.name, pkg.latest_version || '(no version)', pkg.owner, pkg.repo, pkg.desc);
              }
            } else {
              log('No package found'.red);
            }
          }, function (error) {
            if (error.code === 404) {
              log('Package not found'.red);
            } else {
              log('Error while trying to get the resource, server code:'.red, error.code || error);
            }
            exit = 1;
          });

        break;

      case 'create':
          
        if (!pkgname) {
          log('Package name option required. Type --help'.red);
          exit = 1;
          return;
        }

        if (!pkgfile) {
          log('No input file specified, looking for .bintray'.grey);
          pkgfile = '.bintray'; // default file (proposal)
        }

        if (!fs.existsSync(pkgfile)) {
          log('File not found.'.red);
          exit = 1;
          return;
        }

        try {
          var pkgObj = JSON.parse(fs.readFileSync(path.resolve(pkgfile)));
        } catch (e) {
          log('Error parsing JSON file:', e.message);
          exit = 1;
          return;
        }

        client.createPackage(pkgObj)
          .then(function (response) {
            if (response.code === 201) {
              log('Package created successfully'.green);
            }
          }, function (error) {
            if (error.code === 409) {
              log('The package already exists. Use --force to override it'.red);
              // todo: delete package
            } else {
              log('Cannot create the package, server code:'.red, error.code || error);
            }
            exit = 1;
          });

        break;

      case 'delete':

        if (!pkgname) {
          log('Package name option required. Type --help'.red);
          exit = 1;
          return;
        }

        client.deletePackage(pkgname)
          .then(function (response) {
            if (response.code === 200) {
              log('Package deleted successfully'.green);
            }
          }, function (error) {
            if (error.code === 404) {
              log('Package not found'.red);
            } else {
              log('Error while trying to remove the resource, server code:'.red, error.code || error);
            }
            exit = 1;
          });

        break;

      case 'update':

        if (!pkgname) {
          log('Package name option required. Type --help'.red);
          exit = 1;
          return;
        }

        if (!pkgfile) {
          log('No input file specified, looking for .bintray'.grey);
          pkgfile = '.bintray'; // default file (proposal)
        }

        if (!fs.existsSync(pkgfile)) {
          log('File not found.'.red);
          exit = 1;
          return;
        }

        try {
          var pkgObj = JSON.parse(fs.readFileSync(path.resolve(pkgfile)));
        } catch (e) {
          log('Error parsing JSON file:', e.message);
          exit = 1;
          return;
        }

        client.updatePackage(pkgname, pkgObj)
          .then(function (response) {
            if (response.code === 200) {
              log('Package updated successfully'.green);
            }
          }, function (error) {
            if (error.code === 404) {
              log('Package not found'.red);
            } else {
              log('Error while trying to get the resource, server code:'.red, error.code || error);
            }
            exit = 1;
          });

        break;
    }

  });

program.parse(process.argv);

process.on('exit', function () { process.exit(exit); });